# Middlewares

Un pipe es una cadena de procesos a cada uno de los procesos los llamamos
middleware, ejemplo: El middleware de autorizacion.

Area de middlewares en program.cs

```csharp
var app = builder.Build();

// area de middlewares

app.MapGet("/", () => "Hello World!");
app.Run();
```

## Middleware de Gestión Global de Excepciones

Este es un middleware muy común en apis, utiliza el método más moderno y recomendado en .NET (la interfaz IExceptionHandler, introducida en .NET 8.
Nuestro objetivo es crear ese "Gerente" (el middleware) que atrape cualquier error que ocurra en cualquier parte de la aplicación, para que no tengamos que escribir try-catch en cada uno de nuestros controladores.

Paso 1: Crear el Manejador
Ruta: (StarWarsCRUD.Api\Middlewares\GlobalExceptionHandler.cs)

```csharp
using Microsoft.AspNetCore.Diagnostics;
using Microsoft.AspNetCore.Mvc;

namespace StarWarsCRUD.Api.Middlewares;
public class GlobalExceptionHandler(ILogger<GlobalExceptionHandler> logger) : IExceptionHandler
{
    // Usamos ILogger para registrar el error
    private readonly ILogger<GlobalExceptionHandler> _logger = logger;

    public async ValueTask<bool> TryHandleAsync(HttpContext httpContext,
                                                Exception exception,
                                                CancellationToken cancellationToken)
    {
        // 1. REGISTRAR EL ERROR (LOGGING)
        // Registramos el error con todo el detalle (stack trace) en nuestra consola o sistema de logs.
        // Esto es para los desarrolladores.
        _logger.LogError(exception, "Ocurrió una excepción no controlada: {Mensaje}", exception.Message);

        // 2. RESPUESTA AMIGABLE (PARA EL CLIENTE)
        // Usamos ProblemDetails, que es un estándar (RFC 7807) para reportar errores en APIs.
        var problemDetails = new ProblemDetails
        {
            Status = StatusCodes.Status500InternalServerError,
            Title = "Error interno del servidor",
            Detail = "Ocurrió un error inesperado. Por favor, intente de nuevo más tarde."
        };

        // (Opcional) Si estás en Desarrollo, se puede añadir más detalles:
        // if (_env.IsDevelopment())
        // {
        //     problemDetails.Detail = exception.ToString();
        // }

        // 3. ENVIAR LA RESPUESTA
        // Establecemos el código de estado y escribimos la respuesta JSON.
        httpContext.Response.StatusCode = StatusCodes.Status500InternalServerError;
        await httpContext.Response.WriteAsJsonAsync(problemDetails, cancellationToken);

        // 4. INDICAR QUE EL ERROR FUE MANEJADO
        // Devolvemos 'true' para decirle al pipeline de .NET que este error
        // ya fue gestionado y no necesita seguir propagándose.
        return true;
    }
}
```

El CancellationToken permite cancelar una operación asíncrona si el cliente corta la conexión o la petición se detiene.
En otras palabras:
Si el usuario cierra el navegador o cancela la request, el token avisa a tu código para que deje de ejecutar esa tarea y no siga gastando recursos.

Paso 2: Registrar el Manejador en Program.cs
Ahora que tenemos nuestro "Gerente", debemos decirle a .NET que existe y que debe usarlo.

```csharp
var builder = WebApplication.CreateBuilder(args);
// area configuración de servicios

// 1. AÑADIMOS EL MANEJADOR DE EXCEPCIONES AL CONTENEDOR DE SERVICIOS
// Le decimos a .NET: "Tengo un manejador de excepciones personalizado llamado GlobalExceptionHandler"
builder.Services.AddExceptionHandler<GlobalExceptionHandler>();
// (Importante) También necesitamos este servicio para que ProblemDetails funcione correctamente
builder.Services.AddProblemDetails();
// fin del area de configuración de servicios

var app = builder.Build();

// 2. AÑADIMOS EL MIDDLEWARE AL PIPELINE
// Le decimos a .NET: "Activa el middleware de gestión de excepciones"
// Este debe ir MUY ARRIBA en el pipeline para atrapar errores de middlewares posteriores.
app.UseExceptionHandler();
app.Run();
```

Para verificar si fue implementado correctamente podemos forzar un error:

1. Ve a cualquiera de tus controladores (por ejemplo, PersonajeController).
2. Crea un nuevo endpoint de prueba que simplemente lance un error:

```csharp
[ApiController]
[Route("[controller]")]
public class PersonajeController : ControllerBase
{
    [HttpGet("test-error")]
    public IActionResult TestError()
    {
        // Simulamos un error inesperado
        throw new InvalidOperationException("¡Este es un error de prueba para el middleware!");
    }
}
```

3. Ejecutar api y navegar a este endpoint (ej: .../Personaje/test-error).
   Resultado: En el Navegador/Postman: no aparecerá un stack trace feo. sinó la respuesta JSON limpia que definimos:
   ```JSON
   {
   "status": 500,
   "title": "Error interno del servidor",
   "detail": "Ocurrió un error inesperado. Por favor, intente de nuevo más tarde."
   }
   ```

En la Consola (donde corre el dotnet run): Verás el log del error con todos los detalles, gracias a nuestro ILogger:

```console
fail: GlobalExceptionHandler[0]
      Ocurrió una excepción no controlada: Este es un error de prueba para el middleware!
      System.InvalidOperationException: ¡Este es un error de prueba para el middleware!
         at StarWarsCRUD.Api.Controllers.PersonajeController.TestError() in ...\PersonajeController.cs:line XX
         ... (stack trace completo) ...
```

## Otra forma de crear middlewares

Otra forma de crear middlewares sin llenar de codigo la clase Program.cs es creandolos en sus
propias clases con metodos extensivos.
Ejemplo con dos middlewares

Primer Middleware:
Paso 1 (StarWarsCRUD.Api\Middlewares\LogueaParticionMiddlewars.cs)

```csharp
namespace StarWarsCRUD.Api.Middlewares;

public class LogueaParticionMiddlewars
{
    private readonly RequestDelegate _next;

    public LogueaParticionMiddlewars(RequestDelegate next)
    {
        _next = next;
    }
    public async  Task InvokeAsync(HttpContext contexto)
    {
        // viene la petición
        var logger = contexto.RequestServices
                             .GetRequiredService<ILogger<Program>>();
        logger.LogInformation($"Petición: {contexto.Request.Method} {contexto.Request.Path}");

        // continua el flujo hacia el siguiente middleware
        await _next.Invoke(contexto);

        //se va la respuesta
        logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}")
    }
}

// metodo de extensión para agregar el middleware al pipeline
public static class LogueaPeticionMiddlewareExtensions
{
    public static IApplicationBuilder UseLogueaPeticion(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<LogueaParticionMiddlewars>();
    }
}
```

Paso 2
En Program.cs
Nota: el orden de los middleware es importante por que se ejecuta en el orden en que se agregan

```csharp

// agregamos el middleware personalizado para logueo de peticiones
app.UseLogueaPeticion();

app.Run();
```

Segundo Middleware:

Paso 1 (\StarWarsCRUD.Api\Middlewares\BloqueaPeticionMiddleware.cs)

```csharp
namespace StarWarsCRUD.Api.Middlewares;
public class BloqueaPeticionMiddleware
{
    private readonly RequestDelegate _next;

    public BloqueaPeticionMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext contexto)
    {
        if (contexto.Request.Path == "/bloqueado")
        {
            contexto.Response.StatusCode = 403; // Forbidden
            await contexto.Response.WriteAsync("acceso denegado");
        }
        else
        {
            await _next.Invoke(contexto);
        }
    }
}

public static class BLoqueaPeticionMiddlewareExtensions
{
    public static IApplicationBuilder UseBloqueaPeticion(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<BloqueaPeticionMiddleware>();
    }
}
```

Paso 2 Program.cs

```csharp
// agregamos el middleware personalizado para logueo de peticiones
app.UseLogueaPeticion();
app.UseBloqueaPeticion();
app.Run();
```

## Profundización en middlewares basados en clases

RequestDelegate:
Es la firma de una función que puede procesar una petición HTTP. Es la referencia al siguiente elemento en la cadena (el pipeline).

\_next.Invoke(contexto):
Esta llamada es crucial. Le dice al pipeline: "Mi trabajo ha terminado por ahora, deja que el siguiente middleware se ejecute."

HttpContext:
Es un objeto que viaja por todo el pipeline. Contiene toda la información de la petición (contexto.Request) y la respuesta (contexto.Response).

Método de Extensión:
Permite usar una sintaxis más limpia (app.UseMiMiddleware()) en lugar de la sintaxis verbosa (app.UseMiddleware<MiMiddleware>()) en el Program.cs.

### 1. Middleware de Logueo de Peticiones (LogueaParticionMiddlewars)

Este middleware registra en la consola información sobre la petición entrante y la respuesta saliente. Es fundamental para el diagnóstico.

Paso 1: Creación de la Clase (El Núcleo)

| Elemento             | Código                                                                 | Documentación para Trainee                                                                                     |
| -------------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| Constructor          | `public LogueaParticionMiddlewars(RequestDelegate next)`               | Recibe `RequestDelegate` (\_next). Obligatorio en middleware basado en clase. .NET lo inyecta automáticamente. |
| Método `InvokeAsync` | `public async Task InvokeAsync(HttpContext contexto)`                  | Método que se ejecuta en cada petición. Debe llamarse `Invoke` o `InvokeAsync`.                                |
| Antes de `_next`     | `logger.LogInformation(...);`                                          | Se ejecuta cuando **entra** la petición (ej.: registrar `Method` y `Path`).                                    |
| Continuar Flujo      | `await _next.Invoke(contexto);`                                        | Pasa la petición al siguiente middleware. La ejecución **regresa aquí** después.                               |
| Después de `_next`   | `logger.LogInformation(...);`                                          | Se ejecuta cuando la **respuesta sale** del pipeline (ej.: registrar `StatusCode`).                            |
| Falla Corregida      | `logger.LogInformation($"Respuesta: {contexto.Response.StatusCode}");` | La llamada debe terminar en **;** para compilar correctamente.                                                 |

Paso 2: Método de Extensión

```csharp
public static class LogueaPeticionMiddlewareExtensions
{
    public static IApplicationBuilder UseLogueaPeticion(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<LogueaParticionMiddlewars>();
    }
}
```

- Propósito: Simplifica la adición del middleware en Program.cs.
- Mecanismo: El método UseMiddleware<T>() es el método estándar de .NET que añade la clase LogueaParticionMiddlewars al pipeline.

### 2. Middleware de Bloqueo Condicional (BloqueaPeticionMiddleware)

Este middleware muestra cómo detener el flujo del pipeline bajo ciertas condiciones, sirviendo como una barrera de seguridad o control.

Paso 1: Creación de la Clase (La Barrera)

| Elemento                | Código                                                                                       | Documentación para Trainee                                                                     |
| ----------------------- | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| Condición de Bloqueo    | `if (contexto.Request.Path == "/bloqueado")`                                                 | Verifica si la ruta solicitada es `/bloqueado`. Si lo es, el middleware bloqueará la petición. |
| Bloqueo (Cortocircuito) | `contexto.Response.StatusCode = 403; await contexto.Response.WriteAsync("acceso denegado");` | Responde inmediatamente sin llamar a `_next`. Esto **detiene** el pipeline (short-circuiting). |
| Flujo Permitido         | `else { await _next.Invoke(contexto); }`                                                     | Si la ruta no está bloqueada, la petición continúa al siguiente middleware o controlador.      |

Paso 2: Registro en Program.cs

```csharp
// El orden es CRUCIAL
app.UseLogueaPeticion(); // <-- Ejecución 1: Registra la Petición Entrante
app.UseBloqueaPeticion(); // <-- Ejecución 2: Revisa si el path es /bloqueado
app.Run();
```

- Si la petición es a /bloqueado, el LogueaPeticion registrará la entrada, el BloqueaPeticion generará el 403, y el flujo regresará a LogueaPeticion para registrar la respuesta 403.

- Si la petición es a un controlador, ambos middlewares se ejecutarán en secuencia normal.
