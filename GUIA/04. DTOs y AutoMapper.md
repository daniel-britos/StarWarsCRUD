# DTOs y AutoMapper

En ocaciones no queremos mostrar toda la data contenida en las entidades y en otras ocaciones
necesitamos transformar la data que queremos mostrar. Por ejemplo concatenando un dato de una columna de una tabla con el dato de otra columa, como columna Nombre con columna Apellido.
Un DTO (data transformation object) nos sirve para transportar datos entre procesos.
En cada DTO colocaremos lo que nosotros querramos que el cliente vea de cada entidad.

Ejmeplo entidad Personaje:

```csharp
public class Personaje
{
    public int Id { get; private set; }
    public string Nombre { get; private set; }
    public string? Descripcion { get; private set; }
    public byte[]? RowVersion { get; private set; }
    public int PlanetaNatalId { get; private set; }
    public Planeta PlanetaNatal { get; private set; }
    private readonly HashSet<Pelicula> _peliculas = new();
    public IReadOnlyCollection<Pelicula> Peliculas => _peliculas;
    public IReadOnlyCollection<Nave> Naves => _naves;
    private Personaje() { }
    public Personaje(string nombre, Planeta planetaNatal){
        ......
    }
    public void AgregarNave(Nave nave) {
        ......
    }
    public void ActualizarDescripcion(string nuevaDescripcion) {
        ........
    }
    public void AgregarAparicionEnPelicula(Pelicula pelicula){
        ........
    }
}

```

Ejemplo DTO de entidad Personaje

```csharp
public class PersonajeResponse
{
    public int Id { get; init; }
    public string Nombre { get; init; }
    public string? Descripcion { get; init; }
    public string? Historia { get; init; }
    public PlanetaSummary? PlanetaNatal { get; init; }
    pu
```

Mostrando datos de DTO y transformando la respuesta (Nombre + Descripcion).

```csharp
    // Get con datos de columnas combinados
    [HttpGet()]
    public async Task<IEnumerable<PersonajeResponse>> GetColumns()
    {
        var personajes = await _context.Personajes.ToListAsync();
        var personajesDto = personajes.Select(p => new PersonajeResponse{ Id = p.Id,
                                                        Nombre = $"{p.Nombre} {p.Descripcion}"});

        return personajesDto;
    }
```

Para una web api pequeña puede usarse el metodo anterior, en este caso solo estamos mapeando
Nombre y Descripcion. Pero si fuesen más propiedades ya tendriamos un problema y para eso existen
los automapper.

## AutoMapper

1. Instalación de AutoMapper.
   En la capa donde estamos trabajando instalamos el Nugget de automapper.
   Click derecho capa StarWarsCRUD.Api -> Package Nugget Manager y agregamos el primer
   resultado (AutoMapper) y (.DependencyInjection)

2. Configuración en Program.cs
   En el sector de servicios en Program.cs agregamos:

```csharp
builder.Services.AddAutoMapper(typeof(Program)); // aca le estoy diciendo "busca las configuraciones en el proyecto con la clase Program

```

3. Creamos Perfiles de Automapper
   En nuestra capa Api creamos una clase nueva
   StarWarsCRUD.Api\Profiles\AutoMapperProfile.cs

```csharp
using AutoMapper;

namespace StarWarsCRUD.Api.Profiles;

public class AutoMapperProfile : Profile
{
    public AutoMapperProfile()
    {
        // configuración de respuesta con transformación de datos.
        CreateMap<Personaje, PersonajeResponse>()
                 .ForMember(dto => dto.Nombre,
                  config => config.MapFrom(p => $"{p.Nombre} {p.Descripcion}"));
    }
}
```

4. Inyectamos el servicio IMapper en nuestro controlador

```csharp
    private readonly IMapper mapper;
    public PersonajesController(ApplicationDbContext context,
                                IMapper mapper)
    {
        _context = context;
        _mapper = mapper;
    }
```

5. Usamos en el metodo del controlador

```csharp
    [HttpGet()]
    public async Task<IEnumerable<PersonajeResponse>> Get()
    {
        //Sin Automapper
        //var personajes = await _context.Personajes.ToListAsync();
        //var personajesDto = personajes.Select(p => new PersonajeResponse{ Id = p.Id,
        //                                                Nombre = $"{p.Nombre} {p.Descripcion}"});

        // Con Automapper
        var personajes = await _context.Personajes.ToListAsync();
        //Tomá la lista de personajes que viene de la base de datos y convertímela en una lista del tipo PersonajeResponse usando AutoMapper.
        var personajesDto = _mapper.Map<IEnumerable<PersonajeResponse>>(personajes);

        return personajesDto;
    }

    [HttpPost]
public async Task<ActionResult> Post(CreatePersonajeRequest createPersonajeRequest)
{
    // Convertimos el DTO de entrada (CreatePersonajeRequest) a la entidad Personaje usando AutoMapper
    var personaje = _mapper.Map<Personaje>(createPersonajeRequest);

    // Indicamos al DbContext que queremos agregar este nuevo personaje a la base de datos
    _context.Add(personaje);

    // Guardamos los cambios en la base de datos (INSERT).
    // EF Core ejecuta la operación pendiente (Add) y genera el ID del nuevo registro
    await _context.SaveChangesAsync();

    // Convertimos la entidad guardada (con su nuevo Id) a un DTO para devolverlo al cliente
    var personajeDto = _mapper.Map<CreatePersonajeRequest>(personaje);

    // Retornamos HTTP 201 (Created) + la URL donde se puede consultar el nuevo recurso
    return CreatedAtRoute("GetPersonajes", new { id = personaje.Id }, personajeDto);
}

    [HttpPut("{id:int}")] // api/personajes/id
    public async Task<ActionResult> Put(int id, CreatePersonajeRequest createPersonajeRequest)
    {
        var personaje = _mapper.Map<Personaje>(createPersonajeRequest);
        personaje.Id = id;
        _context.Update(personaje);
        await _context.SaveChangesAsync();
        return Ok();
    }

    // no es necesario usar dtos en delete
    [HttpDelete("{id:int}")]
    public async Task<ActionResult> Delete(int id)
    {
        var registrosBorrados = await _context.Personajes
                                              .Where(p => p.Id == id)
                                              .ExecuteDeleteAsync();
        if (registrosBorrados == 0)
        {
            return NotFound();
        }

        return Ok();
    }
```

Repaso y adicional

## Record/Clases para DTOs

• Usa record para DTOs pequeños, inmutables y sin lógica (summaries).
• Usa class cuando el DTO necesita mutabilidad, atributos/validación o propiedades complejas.
Cuándo elegir:
• record — respuestas ligeras para listas o resúmenes (mejor legibilidad, igualdad por valor).
• class — respuestas completas con colecciones, atributos de serialización o si el DTO puede cambiar tras crearse.
Ejemplo tomado del proyecto:

```csharp
StarWarsCRUD.Api\DTOs\Response\PlanetaSummary.cs
public record PlanetaSummary(int Id, string Nombre);

StarWarsCRUD.Api\DTOs\Response\PlanetaResponse.cs
public class PlanetaResponse
{
    public int Id { get; init; }
    public string Nombre { get; init; }
    public TipoClima? Clima { get; init; }
    public IEnumerable<PersonajeSummary>? PersonajesNativos { get; init; } // colección, DTO más
}
```

AutoMapper (ya en tu perfil):

```csharp
CreateMap<Planeta, PlanetaSummary>()
```

para listas/summary:

```csharp
CreateMap<Planeta, PlanetaResponse>()
```

para respuestas detalladas.
