# Inyección de Dependencias, Acoples y Patrón Repository.

- Queremos tener responsabilidades bien definidas.
- Cuando una clase A utiliza una clase B, decimos que la clase B es una dependencia
  de la clase A

Ejemplo

```csharp
[ApiController]
[Route("api/[controller]")]
public class PersonajesController : ControllerBase
{
    private readonly ApplicationDbContext _dbContext;

    public PersonajesController(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Personaje>>> GetAllAsync()
    {
        var personajes = await _dbContext.Personajes.ToListAsync();
        return Ok(personajes);
    }
}
```

Como la clase "public PersonajesControler(Applic...." utiliza la clase "private readonly ApplicationDbContext ..." decimos que la clase "public class PersonajesController : ..." depende de "private readonly ApplicationDbContext ..."
Nota: En este caso se utiliza acomplamiento fuerte por que estoy obligado a usar ApplicationDbContext para poder instanciar PersonajesController, el objetivo de la Inyección de Dependencias (DI) es lograr un Acoplamiento Débil.

## Acoplamiento Fuerte (El Antipatrón

Es cuando un controlador crea directamente sus propias dependencias usando la palabra clave new.

- Qué es: El controlador "sabe demasiado". Conoce la clase exacta que necesita y es responsable de construirla.
- La Señal: Verás un new dentro del constructor del controlador (o en los métodos).
- Problema: El acoplamiento fuerte es rigido y complica los testing

Volviendo a nuestro controlador, aunque está utilizando Inyección de Dependencias (un patrón que facilita el acoplamiento débil), el controlador sigue estando fuertemente acoplado a una implementación específica

Ese controlador tiene acoplamiento fuerte.

Aunque está utilizando Inyección de Dependencias (un patrón que facilita el acoplamiento débil), el controlador sigue estando fuertemente acoplado a una implementación específica.

¿Por qué es acoplamiento fuerte?
La clave está en esta línea:

```csharp
private readonly ApplicationDbContext _dbContext;

public PersonajesController(ApplicationDbContext dbContext) // <-- este es el problema
{
    _dbContext = dbContext;
}
```

El PersonajesController depende directamente de la clase concreta ApplicationDbContext. Esto significa que el controlador sabe exactamente cómo funciona el acceso a datos: sabe que es Entity Framework Core y que está usando un DbContext.

## Acoplamiento Débil (El Objetivo de DI)

Es cuando el controlador no sabe qué clase concreta está usando; solo conoce una abstracción (una interfaz).

- Qué es: El controlador pide "algo que sepa hacer X" (la interfaz), y el sistema de DI se lo entrega en el constructor
- La Señal: El controlador depende de una interfaz (ej: IPersonajeService) y la recibe como parámetro en el constructor.
- El Beneficio: Flexibilidad, Testing Fácil

¿Cómo sería un acoplamiento débil?
Para lograr un acoplamiento débil, el controlador no debería depender de una clase concreta, sino de una abstracción (generalmente una interfaz).
Este enfoque se conoce comúnmente como el Patrón de Repositorio (Repository Pattern).

Paso 1: Crear una interfaz (la abstracción) generalmente ubicadas en la carpeta
(.Domain/Interfaces/IPersonajeRepository.cs)

```csharp
public interface IPersonajeRepository
{
    Task<IEnumerable<Personaje>> GetAllAsync();
}
```

Paso 2: Crear una implementación (la clase concreta) generalmente en
(.Infrastructure/Repositories/PersonajeRepository.cs)
Esta clase sí conocerá el DbContext, pero el controlador no lo sabrá.

```csharp
public class PersonajeRepository : IPersonajeRepository
{
private readonly ApplicationDbContext _dbContext;

    public PersonajeRepository(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task<IEnumerable<Personaje>> GetAllAsync()
    {
        return await _dbContext.Personajes.ToListAsync();
    }

}
```

Paso 3: Modificar el controlador para usar la interfaz

```csharp
[ApiController]
[Route("api/[controller]")]
public class PersonajesController : ControllerBase
{
// ¡Ahora depende de la interfaz, no de la clase concreta!
private readonly IPersonajeRepository _repository;

    public PersonajesController(IPersonajeRepository repository) // <-- Acoplamiento débil
    {
        _repository = repository;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Personaje>>> GetAllAsync()
    {
        var personajes = await _repository.GetAllAsync();
        return Ok(personajes);
    }
}
```

## Paso a Paso: Implementación del Patrón Repository

Paso 1: Definir la Entidad (Proyecto: .Domain, ej: Personaje)
Paso 2: Definir la Interfaz (Proyecto: .Domain)
Crea la interfaz que define las operaciones que el repositorio debe cumplir.

```csharp
public interface IPersonajeRepository
{
    Task<IEnumerable<Personaje>> GetAllAsync();
    Task<Personaje?> GetByIdAsync(int id);
    Task AddAsync(Personaje personaje);
    Task<bool> ExistsAsync(int id);
    Task SaveChangesAsync();
}
```

Paso 3: Implementar la Interfaz (Proyecto: .Infrastructure)
Ahora, crea la clase concreta que implementa la interfaz usando Entity Framework Core.

Importante: El proyecto .Infrastructure debe tener una referencia al proyecto .Domain (para ver la interfaz IPersonajeRepository y la entidad Personaje).

```csharp
namespace StarWarsCRUD.Infrastructure.Repositories;

public class PersonajeRepository : IPersonajeRepository
{
    private readonly ApplicationDbContext _dbContext;

    public PersonajeRepository(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task<IEnumerable<Personaje>> GetAllAsync()
    {
        return await _dbContext.Personajes
            .AsNoTracking()
            .ToListAsync();
    }

    public async Task<Personaje?> GetByIdAsync(int id)
    {
        return await _dbContext.Personajes
            .FirstOrDefaultAsync(p => p.Id == id);
    }

    public async Task AddAsync(Personaje personaje)
    {
        await _dbContext.Personajes.AddAsync(personaje);
    }

    public async Task<bool> ExistsAsync(int id)
    {
        return await _dbContext.Personajes.AnyAsync(p => p.Id == id);
    }

    public async Task SaveChangesAsync()
    {
        await _dbContext.SaveChangesAsync();
    }
}
```

Paso 4: Registrar la Inyección de Dependencias (Proyecto: .Api)
Debes decirle al contenedor de servicios qué clase concreta usar cuando se solicite una interfaz. Esto se hace en el archivo Program.cs del proyecto de API

```csharp
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// 2. Registra el repositorio (El "pegamento")
// "Cuando alguien pida IPersonajeRepository (de .Domain),
// entrégale una instancia de PersonajeRepository (de .Infrastructure)"
builder.Services.AddScoped<IPersonajeRepository, PersonajeRepository>();
```

acoplar a interfaces permite: Mockear repositorios Testear el controlador sin EF Core real

NOTA: EF Core ya implementa patrones Repository y Unit of Work.
Usar un repositorio manual es opcional, pero útil para prácticas Clean Architecture y futuros escenarios complejos.

Un Repository es responsable de:

1. Consultar entidades
2. Agregar, eliminar, actualizar
3. Filtrar, paginar, etc.

EF Core hace eso:
EstoO ya es un repositorio.

```csharp
 _dbContext.Personajes.ToListAsync();
 _dbContext.Personajes.AddAsync(personaje);
 _dbContext.Personajes.FindAsync(id);
```

EF Core como Unit of Work
El patrón Unit of Work coordina todos los cambios y los guarda en una sola transacción:
EF Core ya lo hace también.

```csharp
await _dbContext.SaveChangesAsync();
```

En proyectos simples, es aceptable usar solo DbContext directamente en el Service o Controller.
En proyectos profesionales grandes, sí se usa interface en Application / Domain y repo en Infrastructure.

Cuándo NO crear repositorios manuales:

1. Proyectos CRUD simples o medianos
2. Microservicios pequeños
3. APIs donde EF Core por sí mismo es suficiente
   En estos casos, un repositorio manual puede ser ruido innecesario.

Cuándo SÍ crear repositorios manuales:

1. Arquitectura limpia / DDD
2. Multi-capa estricta
3. Reglas de negocio complejas
4. Capacitación/estudio para prácticas profesionales
5. Necesidad de testear sin EF Core real
