# Inyecci√≥n de Dependencias y tipos de acoplamientos.

- Queremos tener responsabilidades bien definidas.
- Cuando una clase A utiliza una clase B, decimos que la clase B es una dependencia
  de la clase A

Ejemplo

```csharp
[ApiController]
[Route("api/[controller]")]
public class PersonajesController : ControllerBase
{
    private readonly ApplicationDbContext _dbContext;

    public PersonajesController(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Personaje>>> GetAllAsync()
    {
        var personajes = await _dbContext.Personajes.ToListAsync();
        return Ok(personajes);
    }
}
```

Como la clase "public PersonajesControler(Applic...." utiliza la clase "private readonly ApplicationDbContext ..." decimos que la clase "public class PersonajesController : ..." depende de "private readonly ApplicationDbContext ..."
Nota: En este caso se utiliza acomplamiento fuerte por que estoy obligado a usar ApplicationDbContext para poder instanciar PersonajesController, el objetivo de la Inyecci√≥n de Dependencias (DI) es lograr un Acoplamiento D√©bil.

## Acoplamiento Fuerte (El Antipatr√≥n

Es cuando un controlador crea directamente sus propias dependencias usando la palabra clave new.

- Qu√© es: El controlador "sabe demasiado". Conoce la clase exacta que necesita y es responsable de construirla.
- La Se√±al: Ver√°s un new dentro del constructor del controlador (o en los m√©todos).
- Problema: El acoplamiento fuerte es rigido y complica los testing

Volviendo a nuestro controlador, aunque est√° utilizando Inyecci√≥n de Dependencias (un patr√≥n que facilita el acoplamiento d√©bil), el controlador sigue estando fuertemente acoplado a una implementaci√≥n espec√≠fica

Ese controlador tiene acoplamiento fuerte.

Aunque est√° utilizando Inyecci√≥n de Dependencias (un patr√≥n que facilita el acoplamiento d√©bil), el controlador sigue estando fuertemente acoplado a una implementaci√≥n espec√≠fica.

¬øPor qu√© es acoplamiento fuerte?
La clave est√° en esta l√≠nea:

```csharp
private readonly ApplicationDbContext _dbContext;

public PersonajesController(ApplicationDbContext dbContext) // <-- este es el problema
{
    _dbContext = dbContext;
}
```

El PersonajesController depende directamente de la clase concreta ApplicationDbContext. Esto significa que el controlador sabe exactamente c√≥mo funciona el acceso a datos: sabe que es Entity Framework Core y que est√° usando un DbContext.

## Acoplamiento D√©bil (El Objetivo de DI)

Es cuando el controlador no sabe qu√© clase concreta est√° usando; solo conoce una abstracci√≥n (una interfaz).

- Qu√© es: El controlador pide "algo que sepa hacer X" (la interfaz), y el sistema de DI se lo entrega en el constructor
- La Se√±al: El controlador depende de una interfaz (ej: IPersonajeService) y la recibe como par√°metro en el constructor.
- El Beneficio: Flexibilidad, Testing F√°cil

¬øC√≥mo ser√≠a un acoplamiento d√©bil?
Para lograr un acoplamiento d√©bil, el controlador no deber√≠a depender de una clase concreta, sino de una abstracci√≥n (generalmente una interfaz).
Este enfoque se conoce com√∫nmente como el Patr√≥n de Repositorio (Repository Pattern).

Paso 1: Crear una interfaz (la abstracci√≥n) generalmente ubicadas en la carpeta
(.Domain/Interfaces/IPersonajeRepository.cs)

```csharp
public interface IPersonajeRepository
{
    Task<IEnumerable<Personaje>> GetAllAsync();
}
```

Paso 2: Crear una implementaci√≥n (la clase concreta) generalmente en
(.Infrastructure/Repositories/PersonajeRepository.cs)
Esta clase s√≠ conocer√° el DbContext, pero el controlador no lo sabr√°.

```csharp
public class PersonajeRepository : IPersonajeRepository
{
private readonly ApplicationDbContext _dbContext;

    public PersonajeRepository(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task<IEnumerable<Personaje>> GetAllAsync()
    {
        return await _dbContext.Personajes.ToListAsync();
    }

}
```

Paso 3: Modificar el controlador para usar la interfaz

```csharp
[ApiController]
[Route("api/[controller]")]
public class PersonajesController : ControllerBase
{
// ¬°Ahora depende de la interfaz, no de la clase concreta!
private readonly IPersonajeRepository _repository;

    public PersonajesController(IPersonajeRepository repository) // <-- Acoplamiento d√©bil
    {
        _repository = repository;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Personaje>>> GetAllAsync()
    {
        var personajes = await _repository.GetAllAsync();
        return Ok(personajes);
    }
}
```

Aqu√≠ tienes la respuesta concreta y el paso a paso.

üìç Ubicaci√≥n Profesional de Directorios
Interfaz (IPersonajeRepository.cs) Va en el proyecto de Dominio, ya que define el contrato que la l√≥gica de negocio necesita.

TuSolucion.Domain/Interfaces/IPersonajeRepository.cs
Implementaci√≥n (PersonajeRepository.cs) Va en el proyecto de Infraestructura, ya que es un detalle t√©cnico (en este caso, c√≥mo EF Core accede a los datos).

TuSolucion.Infrastructure/Repositories/PersonajeRepository.cs
üöÄ Paso a Paso: Implementaci√≥n del Patr√≥n
Asumiendo que ya tienes tu proyecto con las 4 capas (.Api, .Application, .Domain, .Infrastructure):

Paso 1: Definir la Entidad (Proyecto: .Domain)
Aseg√∫rate de tener tu entidad.

Archivo: TuSolucion.Domain/Entities/Personaje.cs

C#

namespace TuSolucion.Domain.Entities
{
public class Personaje
{
public int Id { get; set; }
public string Nombre { get; set; }
// ... otras propiedades
}
}
Paso 2: Definir la Interfaz (Proyecto: .Domain)
Crea la interfaz que define las operaciones que el repositorio debe cumplir.

Archivo: TuSolucion.Domain/Interfaces/IPersonajeRepository.cs

C#

using TuSolucion.Domain.Entities;

namespace TuSolucion.Domain.Interfaces
{
public interface IPersonajeRepository
{
Task<Personaje> GetByIdAsync(int id);
Task<IEnumerable<Personaje>> GetAllAsync();
Task AddAsync(Personaje personaje);
// ... otros m√©todos (Update, Delete, etc.)
}
}
Paso 3: Implementar la Interfaz (Proyecto: .Infrastructure)
Ahora, crea la clase concreta que implementa la interfaz usando Entity Framework Core.

Importante: El proyecto .Infrastructure debe tener una referencia al proyecto .Domain (para ver la interfaz IPersonajeRepository y la entidad Personaje).

Asunci√≥n: Ya tienes tu ApplicationDbContext.cs en TuSolucion.Infrastructure/Data/.

Archivo: TuSolucion.Infrastructure/Repositories/PersonajeRepository.cs

C#

using Microsoft.EntityFrameworkCore;
using TuSolucion.Domain.Entities;
using TuSolucion.Domain.Interfaces;
using TuSolucion.Infrastructure.Data; // <-- Necesitas tu DbContext

namespace TuSolucion.Infrastructure.Repositories
{
public class PersonajeRepository : IPersonajeRepository
{
private readonly ApplicationDbContext \_context;

        public PersonajeRepository(ApplicationDbContext context)
        {
            _context = context;
        }

        public async Task<Personaje> GetByIdAsync(int id)
        {
            return await _context.Set<Personaje>().FindAsync(id);
        }

        public async Task<IEnumerable<Personaje>> GetAllAsync()
        {
            return await _context.Set<Personaje>().ToListAsync();
        }

        public async Task AddAsync(Personaje personaje)
        {
            await _context.Set<Personaje>().AddAsync(personaje);
            // Nota: Generalmente se necesita un m√©todo SaveChangesAsync(),
            // a menudo manejado por una Unidad de Trabajo (Unit of Work).
        }
    }

}

Paso 4: Registrar la Inyecci√≥n de Dependencias (Proyecto: .Api)
Debes decirle al contenedor de servicios qu√© clase concreta usar cuando se solicite una interfaz. Esto se hace en el archivo Program.cs del proyecto de API

```csharp
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// 2. Registra el repositorio (El "pegamento")
// "Cuando alguien pida IPersonajeRepository (de .Domain),
// entr√©gale una instancia de PersonajeRepository (de .Infrastructure)"
builder.Services.AddScoped<IPersonajeRepository, PersonajeRepository>();
```

acoplar a interfaces permite: Mockear repositorios Testear el controlador sin EF Core real

NOTA: EF Core ya implementa patrones Repository y Unit of Work.
Usar un repositorio manual es opcional, pero √∫til para pr√°cticas Clean Architecture y futuros escenarios complejos.

Un Repository es responsable de:

1. Consultar entidades
2. Agregar, eliminar, actualizar
3. Filtrar, paginar, etc.

EF Core hace eso:
EstoO ya es un repositorio.

```csharp
 _dbContext.Personajes.ToListAsync();
 _dbContext.Personajes.AddAsync(personaje);
 _dbContext.Personajes.FindAsync(id);
```

EF Core como Unit of Work
El patr√≥n Unit of Work coordina todos los cambios y los guarda en una sola transacci√≥n:
EF Core ya lo hace tambi√©n.

```csharp
await _dbContext.SaveChangesAsync();
```

En proyectos simples, es aceptable usar solo DbContext directamente en el Service o Controller.
En proyectos profesionales grandes, s√≠ se usa interface en Application / Domain y repo en Infrastructure.

Cu√°ndo NO crear repositorios manuales:

1. Proyectos CRUD simples o medianos
2. Microservicios peque√±os
3. APIs donde EF Core por s√≠ mismo es suficiente
   En estos casos, un repositorio manual puede ser ruido innecesario.

Cu√°ndo S√ç crear repositorios manuales:

1. Arquitectura limpia / DDD
2. Multi-capa estricta
3. Reglas de negocio complejas
4. Capacitaci√≥n/estudio para pr√°cticas profesionales
5. Necesidad de testear sin EF Core real
