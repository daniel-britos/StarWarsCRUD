# 3. Entidades

√Åmbito y ubicaci√≥n de los archivos

- Entidades principales (carpeta): `StarWarsCRUD.Domain\Entities\`
  - `Personaje.cs`
  - `Planeta.cs`
  - `Pelicula.cs`
  - `Nave.cs`
- Enum:
  - `StarWarsCRUD.Domain\Enums\
  - TipoClima.cs
  - ModeloNave.cs

Resumen de las decisiones de dise√±o (alto nivel)

- Encapsulaci√≥n fuerte: propiedades con setters privados; mutaciones solo a trav√©s de m√©todos de dominio o constructores p√∫blicos validados.
- Constructores p√∫blicos con guard clauses para asegurar invariantes desde la creaci√≥n.
- Constructor sin par√°metros privado para permitir la materializaci√≥n por EF Core.
- Colecciones privadas y expuestas como `IReadOnlyCollection<T>` para evitar mutaciones externas.
- Sincronizaci√≥n expl√≠cita y sim√©trica de relaciones (evita inconsistencias y recursi√≥n infinita mediante guards).
- Uso de `HashSet<T>` en colecciones de navegaci√≥n para unicidad y mejor performance.
- FK expl√≠cita para 1:N (`PlanetaNatalId` en `Personaje`) para mayor claridad en mapping y DTOs.
- Tokens de concurrencia opcionales (`RowVersion`) preparados en entidades para soportar concurrencia optimista (requiere configuraci√≥n en DbContext).

## Implementaci√≥n

1. Utilizamos enums para:
   ‚Ä¢ Seguridad de tipo
   ‚Ä¢ Documentaci√≥n y restricci√≥n
   ‚Ä¢ Legibilidad y mantenimiento

```csharp
namespace StarWarsCRUD.Domain.Enums;

public enum TipoClima
{
    Templado,
    Arido,
    Tropical,
    Artico,
    Volcanico
}
```

2. Creaci√≥n de entidades

‚Ä¢ Idea principal: usar private set protege el estado interno de la entidad. Evita que cualquier parte del c√≥digo cambie propiedades directamente y rompa invariantes del objeto.

¬øPor qu√© es √∫til?
‚Ä¢ Encapsulaci√≥n: fuerza a cambiar estado mediante m√©todos controlados
‚Ä¢ Invariantes de la entidad: las reglas del dominio (p. ej. ‚Äúun personaje siempre debe tener Nombre no vac√≠o‚Äù) se aplican en el constructor o en m√©todos; private set evita que otro c√≥digo esquive esas reglas.
‚Ä¢ API m√°s clara: los consumidores usan comportamientos (m√©todos) en vez de manipular datos arbitrariamente. Esto hace el c√≥digo m√°s intencional y m√°s f√°cil de mantener.
‚Ä¢ ORM-compatible: EF Core puede materializar entidades y escribir en propiedades con private set. No se pierde compatibilidad con el mapeo.
‚Ä¢ Facilita refactor y razonamiento: cuando se ve private set, se sabe que la propiedad es parte del estado controlado por la entidad y no un simple DTO mutable.

```csharp
namespace StarWarsCRUD.Domain.Entities;

public class Personaje
{
    public int Id { get; private set; }
    public string Nombre { get; private set; } // private set para evitar que se modifique desde fuera de la clase.
    public string? Descripcion { get; private set; }
    // rowversion: ayuda a prevenir conflictos cuando multiples usuarios intentan
    // actualizar el mismo registro en la base de datos al mismo tiempo.
    public byte[]? RowVersion { get; private set; }
    // PlanetaNatalId es la clave for√°nea con Planeta
    public int PlanetaNatalId { get; private set; }
    // Propiedad de navegaci√≥n hacia el planeta natal
    public Planeta PlanetaNatal { get; private set; }
    // Relaci√≥n N:N (muchos a muchos) con Pelicula
    // HashSet para evitar duplicados autom√°ticamente
    private readonly HashSet<Pelicula> _peliculas = new();
    // Exponer solo lectura para encapsulaci√≥n
    public IReadOnlyCollection<Pelicula> Peliculas => _peliculas;

    // Creamos un constructor en privado para EF Core y un constructor
    // en publico para la creaci√≥n de instancias v√°lidas
    private Personaje() { }

      // Valida y asigna Nombre y PlanetaNatal, lanza excepciones si son
    // inv√°lidos y registra el Personaje en el Planeta.
    public Personaje(string nombre, Planeta planetaNatal)
    {
        if (string.IsNullOrWhiteSpace(nombre))
            throw new ArgumentException("El nombre no puede estar vac√≠o.", nameof(nombre));

        Nombre = nombre;
        PlanetaNatal = planetaNatal ?? throw new ArgumentNullException(nameof(planetaNatal));

        // Nota: PlanetaNatalId lo manejar√° EF Core; si planetaNatal ya tiene Id,
        // EF sincronizar√° la FK.
        // Sincronizaci√≥n 1:N (lado planeta)
        planetaNatal.AgregarPersonajeNativo(this);
    }

    //Usamos ActualizarDescripcion para validar, normalizar y ejecutar efectos al cambiar; Descripcion con private set solo impide asignaci√≥n externa, sin permitir l√≥gica adicional.
    public void ActualizarDescripcion(string nuevaDescripcion)
    {
        Descripcion = nuevaDescripcion;
    }

    public void AgregarAparicionEnPelicula(Pelicula pelicula)
    {
        if (pelicula == null) throw new ArgumentNullException(nameof(pelicula));
        _peliculas.Add(pelicula);
    }
}
```

RELACIONES:

```csharp
public class Personaje
{
    // Relaci√≥n 1:1 - (Un personaje tiene un solo DatoBiografico){
    public DatosBiograficos DatosBiograficos { get; private set; }

    // Relaci√≥n 1:N ‚Üí Un personaje pertenece a un solo Planeta pero un Planeta puede tener muchos personaje
    public int PlanetaId { get; private set; }
    public Planeta Planeta { get; private set; }

    // Relaci√≥n N:N ‚Üí Un personaje puede aparecer en muchas pel√≠culas y una pel√≠cula puede tener muchos personajes
    private readonly HashSet<Pelicula> _peliculas = new();
    public IReadOnlyCollection<Pelicula> Peliculas => _peliculas;
}
```

```csharp
public class Planeta
{
   // 1:N ‚Üí un planeta puede tener muchos personajes
    private readonly HashSet<Personaje> _personajes = new();
    public IReadOnlyCollection<Personaje> Personajes => _personajes;
}
```

```csharp
public class Pelicula
{
    // Lado inverso del N:N
    private readonly HashSet<Personaje> _personajes = new();
    public IReadOnlyCollection<Personaje> Personajes => _personajes;
}
```

Ejemplo simplificado de 1:N

```csharp
public class Planeta
{
    // üîπ Relaci√≥n 1:N ‚Üí Un planeta tiene muchos personajes
    public List<Personaje> Personajes { get; set; } = new();
}

public class Personaje
{
    // üîπ Clave for√°nea hacia Planeta
    public int PlanetaId { get; set; }

    // üîπ Navegaci√≥n inversa
    public Planeta Planeta { get; set; }
}
```

Configuraci√≥n en DbContext:

```csharp
public class ApplicationDbContext : DbContext
{
    public DbSet<Personaje> Personajes => Set<Personaje>();
    public DbSet<DatosBiograficos> DatosBiograficos => Set<DatosBiograficos>();
    public DbSet<Planeta> Planetas => Set<Planeta>();
    public DbSet<Pelicula> Peliculas => Set<Pelicula>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // 1Ô∏è‚É£ RELACI√ìN 1:1 (Personaje ‚Üî DatosBiograficos)
        modelBuilder.Entity<Personaje>()
            .HasOne(p => p.DatosBiograficos)
            .WithOne(d => d.Personaje)
            .HasForeignKey<DatosBiograficos>(d => d.PersonajeId);

        // 2Ô∏è‚É£ RELACI√ìN 1:N (Planeta ‚Üí Personajes)
        modelBuilder.Entity<Planeta>()
            .HasMany(p => p.Personajes)
            .WithOne(p => p.Planeta)
            .HasForeignKey(p => p.PlanetaId)
            .OnDelete(DeleteBehavior.Restrict);

        // 3Ô∏è‚É£ RELACI√ìN N:N (Personaje ‚Üî Pelicula)
        modelBuilder.Entity<Personaje>()
            .HasMany(p => p.Peliculas)
            .WithMany(p => p.Personajes)
            .UsingEntity(j => j.ToTable("PersonajesPeliculas"));
    }
}
```
