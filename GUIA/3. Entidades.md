# 3. Entidades â€” DiseÃ±o de Dominio (DDD) en StarWarsCRUD

ðŸ“‚ Estructura del Proyecto

UbicaciÃ³n de archivos:
StarWarsCRUD.Domain/
â”œâ”€â”€ Entities/
â”‚ â”œâ”€â”€ Personaje.cs
â”‚ â”œâ”€â”€ Planeta.cs
â”‚ â”œâ”€â”€ Pelicula.cs
â”‚ â””â”€â”€ Nave.cs
â””â”€â”€ Enums/
â”œâ”€â”€ TipoClima.cs
â””â”€â”€ TipoNave.cs

## Principios de DiseÃ±o

- EncapsulaciÃ³n fuerte: todas las propiedades usan private set para evitar modificaciones externas; el estado solo se cambia mediante constructores o mÃ©todos de dominio.
- Constructores validados: los constructores pÃºblicos incluyen guard clauses (ArgumentException, ArgumentNullException) para mantener invariantes desde la creaciÃ³n.
- Constructor privado: requerido por EF Core para la materializaciÃ³n de datos.
- Colecciones inmutables: las relaciones usan HashSet<T> expuesto como IReadOnlyCollection<T> para evitar duplicados y garantizar encapsulaciÃ³n.
- SincronizaciÃ³n explÃ­cita: en relaciones bidireccionales, se asegura coherencia entre ambos lados (Personaje â†” Pelicula).
- Claves forÃ¡neas explÃ­citas: mejoran claridad en el mapping y DTOs.
- Control de concurrencia (RowVersion): todas las entidades principales tienen RowVersion configurado en ModelBuilder para manejar actualizaciones simultÃ¡neas.

## ImplementaciÃ³n de Enums

- Los Enums aportan:
- Seguridad de tipo
- Claridad semÃ¡ntica
- Legibilidad y mantenimiento

```csharp
namespace StarWarsCRUD.Domain.Enums;

public enum TipoClima
{
    Templado,
    Arido,
    Tropical,
    Artico,
    Volcanico
}
```

## Ejemplo de Entidad â€” Personaje

```csharp
namespace StarWarsCRUD.Domain.Entities;

public class Personaje
{
    public int Id { get; private set; }
    public string Nombre { get; private set; }
    public string? Descripcion { get; private set; }
    public byte[]? RowVersion { get; private set; }

    // Relaciones
    public int PlanetaNatalId { get; private set; }
    public Planeta PlanetaNatal { get; private set; }

    private readonly HashSet<Pelicula> _peliculas = new();
    public IReadOnlyCollection<Pelicula> Peliculas => _peliculas;

    private readonly HashSet<Nave> _naves = new();
    public IReadOnlyCollection<Nave> Naves => _naves;

    private Personaje() { }

    public Personaje(string nombre, Planeta planetaNatal)
    {
        if (string.IsNullOrWhiteSpace(nombre))
            throw new ArgumentException("El nombre no puede estar vacÃ­o.", nameof(nombre));

        Nombre = nombre;
        PlanetaNatal = planetaNatal ?? throw new ArgumentNullException(nameof(planetaNatal));

        planetaNatal.AgregarPersonajeNativo(this);
    }

    public void AgregarNave(Nave nave)
    {
        if (nave == null) throw new ArgumentNullException(nameof(nave));
        _naves.Add(nave);
    }

    public void ActualizarDescripcion(string nuevaDescripcion)
    {
        Descripcion = nuevaDescripcion;
    }

    public void AgregarAparicionEnPelicula(Pelicula pelicula)
    {
        if (pelicula == null) throw new ArgumentNullException(nameof(pelicula));
        if (_peliculas.Add(pelicula))
            pelicula.AgregarPersonaje(this);
    }
}
```

## Relaciones entre Entidades

### RelaciÃ³n 1:1

Personaje â†” DatosBiograficos(eliminado en el proyecto)

```csharp
public class Personaje
{
    public DatosBiograficos DatosBiograficos { get; private set; }
}
```

### RelaciÃ³n 1:N

Planeta â†’ Personaje

```csharp
public class Planeta
{
    private readonly HashSet<Personaje> _personajesNativos = new();
    public IReadOnlyCollection<Personaje> PersonajesNativos => _personajesNativos;

    public void AgregarPersonajeNativo(Personaje personaje)
    {
        if (personaje == null) throw new ArgumentNullException(nameof(personaje));
        _personajesNativos.Add(personaje);
    }
}
```

### RelaciÃ³n N:N

Personaje â†” Pelicula

```csharp
public class Pelicula
{
    private readonly HashSet<Personaje> _personajes = new();
    public IReadOnlyCollection<Personaje> Personajes => _personajes;

    public void AgregarPersonaje(Personaje personaje)
    {
        if (personaje == null) throw new ArgumentNullException(nameof(personaje));
        if (_personajes.Add(personaje))
            personaje.AgregarAparicionEnPelicula(this);
    }
}
```

## Ejemplo simplificado de 1:N

```csharp
public class Planeta
{
    public List<Personaje> Personajes { get; set; } = new();
}

public class Personaje
{
    public int PlanetaId { get; set; }
    public Planeta Planeta { get; set; }
}
```

## ConfiguraciÃ³n de Relaciones en DbContext

Archivo: ApplicationDbContext.cs

```csharp
public class ApplicationDbContext : DbContext
{
    public DbSet<Personaje> Personajes => Set<Personaje>();
    public DbSet<Pelicula> Peliculas => Set<Pelicula>();
    public DbSet<Planeta> Planetas => Set<Planeta>();
    public DbSet<Nave> Naves => Set<Nave>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
    }
}
```

## Ejemplo de ConfiguraciÃ³n Modular â€” PeliculaConfiguration

```csharp
public class PeliculaConfiguration : IEntityTypeConfiguration<Pelicula>
{
    public void Configure(EntityTypeBuilder<Pelicula> builder)
    {
        builder.HasKey(m => m.Id);

        builder.Property(m => m.RowVersion)
               .IsRowVersion();

        builder.Property(m => m.FechaEstreno)
               .HasColumnType("date");

        builder.HasMany(m => m.Personajes)
               .WithMany(p => p.Peliculas)
               .UsingEntity(j => j.ToTable("AparicionesEnPeliculas"));
    }
}

```

## Este patrÃ³n modular (IEntityTypeConfiguration<T>) es profesional y recomendado porque:

- Separa las reglas de dominio de la configuraciÃ³n de base de datos.
- Facilita el mantenimiento y la escalabilidad del proyecto.
- Se integra automÃ¡ticamente con ApplyConfigurationsFromAssembly()
