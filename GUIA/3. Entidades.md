# 3. Entidades

Ámbito y ubicación de los archivos
- Entidades principales (carpeta): `StarWarsCRUD.Domain\Entities\`
  - `Personaje.cs`
  - `Planeta.cs`
  - `Pelicula.cs`
  - `DatosBiograficos.cs`
- Enum:
  - `StarWarsCRUD.Domain\Enums\TipoClima.cs`
- Contexto EF Core (para referencia de mapping): `StarWarsCRUD.Infrastructure\Data\ApplicationDbContext.cs`

Resumen de las decisiones de diseño (alto nivel)
- Encapsulación fuerte: propiedades con setters privados; mutaciones solo a través de métodos de dominio o constructores públicos validados.
- Constructores públicos con guard clauses para asegurar invariantes desde la creación.
- Constructor sin parámetros privado para permitir la materialización por EF Core.
- Colecciones privadas y expuestas como `IReadOnlyCollection<T>` para evitar mutaciones externas.
- Sincronización explícita y simétrica de relaciones (evita inconsistencias y recursión infinita mediante guards).
- Uso de `HashSet<T>` en colecciones de navegación para unicidad y mejor performance.
- Mapeo 1:1 modelado como entidad dependiente (`DatosBiograficos`) con PK = FK (EF Core).
- FK explícita para 1:N (`PlanetaNatalId` en `Personaje`) para mayor claridad en mapping y DTOs.
- Tokens de concurrencia opcionales (`RowVersion`) preparados en entidades para soportar concurrencia optimista (requiere configuración en DbContext).

Descripción por entidad

1) `Personaje` (aggregate root)
- Archivos: `StarWarsCRUD.Domain\Entities\Personaje.cs`
- Responsabilidad: representar un personaje del dominio con su información y relaciones.
- Invariantes:
  - `Nombre` no puede ser nulo/vacío (ver constructor público).
  - Debe tener un `PlanetaNatal` al crearse (constructor).
- Relaciones:
  - 1:1 → `DatosBiograficos? DatosBio` (dependiente; asignación mediante `AsignarDatosBiograficos` que valida propiedad `Personaje` de `DatosBiograficos`).
  - 1:N → `Planeta` (propiedad `PlanetaNatal` + FK `PlanetaNatalId`).
  - N:N → `Pelicula` (colección privada `_peliculas` tipo `HashSet<Pelicula>`; método `AgregarAparicionEnPelicula` mantiene la simetría).
- Mutaciones: métodos `ActualizarDescripcion`, `ActualizarHistoria`, `AsignarDatosBiograficos`, `AgregarAparicionEnPelicula`.
- Comentarios técnicos: se adicionó `PlanetaNatalId` para facilitar mapping y uso en DTOs/commands. `RowVersion` está presente si se necesita concurrencia.

2) `Planeta`
- Archivo: `StarWarsCRUD.Domain\Entities\Planeta.cs`
- Responsabilidad: representar el planeta y ser el lado "uno" de la relación 1:N con `Personaje`.
- Invariantes:
  - `Nombre` no puede ser nulo/vacío (constructor).
- Relaciones:
  - 1:N → colección `_personajesNativos` (`HashSet<Personaje>`). Expuesta como `IReadOnlyCollection<Personaje>`.
  - Tiene método `AgregarPersonajeNativo(Personaje)` usado por el constructor de `Personaje` para sincronizar la relación desde el lado del planeta.
- Mutaciones: `ActualizarClima(TipoClima)` para encapsular el cambio de clima.

3) `Pelicula`
- Archivo: `StarWarsCRUD.Domain\Entities\Pelicula.cs`
- Responsabilidad: representar una película con fecha de estreno.
- Invariantes:
  - `Titulo` no puede ser nulo/vacío.
  - `FechaEstreno` validada (ej. no antes de 1970).
- Relaciones:
  - N:N → `Personaje` vía `_personajes` (`HashSet<Personaje>`). `AgregarPersonaje` mantiene la sincronía con `Personaje.AgregarAparicionEnPelicula`.
- Comentarios: `DateOnly` para fechas de estreno (sin componente horario).

4) `DatosBiograficos`
- Archivo: `StarWarsCRUD.Domain\Entities\DatosBiograficos.cs`
- Responsabilidad: contener datos biográficos dependientes de un `Personaje`.
- Diseño:
  - Modelado como entidad dependiente: `public int PersonajeId` y `public Personaje Personaje`.
  - Constructor requiere `Personaje` y valida `AlturaCm`.
  - Métodos para actualizar (`ActualizarAltura`, `ActualizarEspecie`).
- Mapping esperado: 1:1 PK = FK (configurar mediante Fluent API en `ApplicationDbContext` para evitar ambigüedades).

5) `TipoClima` (enum)
- Archivo: `StarWarsCRUD.Domain\Enums\TipoClima.cs`
- Uso: valores permitidos para la propiedad `Clima` en `Planeta`.
- `TipoClima? Clima` permite valores desconocidos/omisos.

Prácticas aplicadas y por qué son recomendables
- Guard clauses en constructores/métodos: evitan construir objetos inválidos y facilitan pruebas unitarias.
- Constructor privado sin parámetros: requisito para EF Core al materializar entidades.
- Colecciones encapsuladas (`private HashSet<T>` + `IReadOnlyCollection<T>`): evita mutaciones externas, garantiza unicidad y mejora rendimiento en Contains/Add.
- Sincronización simétrica de relaciones: mantiene integridad in-memory; evita que un lado se actualice sin el otro.
- FK explícitas: simplifican serialización y mapeo DTO sin cargar toda la navegación.
- No exponer entidades por la API: usar DTOs y mapping (AutoMapper o manual) para evitar problemas (circular refs, sobreexposición de datos, acoplamiento a EF Core).
- Concurrency token (`RowVersion`): recomendable si se espera concurrencia en updates; mapear con `.IsRowVersion()` y manejar DbUpdateConcurrencyException en capa de aplicación.

Configuración EF Core recomendada (fragmentos)
- 1:1 PK = FK (en `ApplicationDbContext.OnModelCreating`):

```csharp
builder.Entity<Personaje>() .HasOne(p => p.DatosBio) .WithOne(d => d.Personaje) .HasForeignKey<DatosBiograficos>(d => d.PersonajeId);
```
- Marcar `RowVersion` como token de concurrencia:

```csharp
builder.Entity<Personaje>().Property(p => p.RowVersion).IsRowVersion();
builder.Entity<Planeta>().Property(p => p.RowVersion).IsRowVersion();
builder.Entity<Pelicula>().Property(p => p.RowVersion).IsRowVersion();
builder.Entity<DatosBiograficos>().Property(d => d.RowVersion).IsRowVersion();
```

- N:N: con EF Core 5+ la convención crea la tabla puente automáticamente si existen dos colecciones de navegación; si necesitas payload en la relación crea entidad explicita y configúrala.

Buenas prácticas para el uso en la API RESTful
- Endpoints deben recibir DTOs (p. ej. `CreatePersonajeDto`) y mapear a entidades a través de constructores/servicios.
- Validación de entrada en la capa API (DataAnnotations o FluentValidation) y luego creación con los constructores del dominio (garantía doble: API valida, dominio refuerza invariantes).
- Transaccionalidad y Unit of Work: realizar todas las mutaciones en servicios/handlers y llamar a `DbContext.SaveChanges()` una vez por operación.
- Manejar `DbUpdateConcurrencyException` para sincronización optimista (si se usa `RowVersion`).
- Pruebas unitarias: cubrir constructores y métodos de dominio; pruebas de integración para mapping EF Core y migrations.

Checklist rápido para entender las entidades en el futuro
- ¿Dónde se validan las invariantes? — en constructores y métodos del dominio.
- ¿Cómo se sincronizan relaciones? — `AgregarAparicionEnPelicula` / `AgregarPersonaje` y `planeta.AgregarPersonajeNativo(this)` en el constructor de `Personaje`.
- ¿Cómo EF Core materializa las entidades? — constructor privado sin parámetros + propiedades con setters privados.
- ¿Dónde configurar relaciones avanzadas? — `StarWarsCRUD.Infrastructure\Data\ApplicationDbContext.cs` (usar Fluent API para 1:1 PK=FK y rowversion).

