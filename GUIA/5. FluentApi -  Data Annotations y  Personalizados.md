# Fluent Api - Data Annotations

EF Core ofrece dos formas principales de configurar el modelo

1. Fluent API (Usado en OnModelCreating)
   - Ubicación: Capa de Infraestructura (separado de la entidad)
   - Control: Máximo control. Necesario para relaciones complejas (N:N, claves compuestas), índices, y acciones de borrado. Se recomienda su uso en aplicaciones medianas o grandes.
   - Limpieza: Mantiene la entidad de dominio limpia y libre de dependencias de infraestructura. (Recomendado para DDD).
   - Sintaxis: Encadenamiento de métodos (.HasOne().WithMany().OnDelete(...)).
2. Data Annotations (Usado en las Clases de Entidad
   Ubicación
   - Caracteristica: Data Annotations (Usado en las Clases de Entidad)
   - Ubicación: Capa de Dominio (directamente en las propiedades).
   - Control: Control limitado. Bueno para restricciones simples ([Required], [MaxLength]).
   - Limpieza: Ensucia el dominio con atributos de la capa de persistencia.
   - Sintaxis: Atributos ([ForeignKey], [Table]).

Para un proyecto de Domain Driven Design (DDD), donde
la lógica de negocio y las restricciones son clave, es imprescindible
usar el Fluent API (OnModelCreating o IEntityTypeConfiguration)
para asegurar que el modelo de la base de datos cumpla exactamente
con las reglas de tu dominio

## Implementación

Este método es donde se utiliza el Fluent API de EF Core, que
permite una configuración detallada que va más allá de lo que las
convenciones o los DataAnnotations pueden ofrecer. Opcionalmente
podemos utilizar modularización mediante IEntityTypeConfiguration
configuradas en la carpeta infraestructure > Data > Configurations

```csharp
namespace StarWarsCRUD.Infrastructure.Data;
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options){ }
    public DbSet<Personaje> Personajes => Set<Personaje>();
    public DbSet<Pelicula> Peliculas => Set<Pelicula>();
    public DbSet<Planeta> Planetas => Set<Planeta>();
    public DbSet<Nave> Naves => Set<Nave>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Se usa typeof(ApplicationDbContext).Assembly para obtener el ensamblado
        // del proyecto StarWarsCRUD.Infrastructure, que contiene tanto el DbContext
        // como todas las clases de configuración (NaveConfiguration, PeliculaConfiguration, etc.)

        // Carga modular de todas las configuraciones
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
    }
}
```

Configuraciónes:

```csharp
namespace StarWarsCRUD.Infrastructure.Data.Configurations;

public class PersonajeConfiguration : IEntityTypeConfiguration<Personaje>
{
    public void Configure(EntityTypeBuilder<Personaje> builder)
    {
        builder.HasKey(p => p.Id);

        /*
         *Podemos configurar restriccionaes en esta parte en lugar de la clase si deseamos.
         *Es recomendable mantener las validaciones en la clase para pequeños proyectos como este
         *para medianos y grandes proyectos es recomendable hacerlo en el modelbuilder de esta manera
         *
           builder.HasKey(p => p.Nombre).IsRequired().HasMaxLength(100);
        */

        // Concurrencia (RowVersion)
        builder.Property(p => p.RowVersion)
            .IsRowVersion();

         // 1. Relación 1:N (con Planeta) - Lado 'Muchos'
        // Ya configurada desde Planeta, solo necesitamos asegurarnos de que la FK es requerida
        // en caso que no lo hayas hecho en la entidad Planeta
        builder.Property(p => p.PlanetaNatalId).IsRequired();

        // 2. Relación 1:N (con Nave) - Lado 'Uno'
        // Un Personaje (Piloto) tiene muchas Naves
        builder.HasMany(p => p.Naves)
            .WithOne(n => n.Piloto)
            .HasForeignKey(n => n.PilotoId) // Usa la FK explícita en Nave
            .OnDelete(DeleteBehavior.SetNull); // O SetNull, o Restrict, según tu regla de negocio

        // 3. Relación N:N (con Pelicula)
        // Usa la convención de nombres para la tabla de unión implícita
        builder.HasMany(p => p.Peliculas)
            .WithMany(m => m.Personajes)
            .UsingEntity(j => j.ToTable("AparicionesEnPeliculas")); // Nombre explícito para la tabla de unión
    }
}

public class NaveConfiguration : IEntityTypeConfiguration<Nave>
{
    public void Configure(EntityTypeBuilder<Nave> builder)
    {
      // Clave Primaria
        builder.HasKey(n => n.Id);

        builder.Property(n => n.RowVersion)
            .IsRowVersion();

        // Relación N:1 (con Personaje) - Lado 'Muchos'
        // Una Nave tiene un Piloto
        builder.HasOne(n => n.Piloto)
            .WithMany(p => p.Naves)
            .HasForeignKey(n => n.PilotoId)
            .IsRequired(false); // Podrías permitir que una nave exista sin piloto al inicio (PilotoId puede ser null)

        // El tipo de enum 'TipoNave' se mapea por defecto a int.
    }
}

```

¿Cómo Conecta EF Core el Código con la Configuración?
En el DbContext: Se utiliza el método modelBuilder.ApplyConfigurationsFromAssembly() para que EF Core, mediante Reflexión (escaneo), encuentre y ejecute todas las clases IEntityTypeConfiguration<T> en el proyecto.

## Data Annotations

```csharp
// Importaciones necesarias para los Data Annotations
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

/// <summary>
/// Entidad Planeta (El lado "Uno" de la relación 1-a-Muchos)
/// </summary>
[Table("Planetas")] // Opcional: Especifica el nombre de la tabla en la BD.
public class Planeta
{
    [Key] // Marca esta propiedad como la Llave Primaria (Primary Key - PK).
    public int Id { get; set; }

   [Required] // Indica que este campo no puede ser nulo (NOT NULL en SQL).
    // Define un tamaño máximo para la cadena {0} implemente "Nombre", {1} implementa 50}
   [StringLength(50, ErrorMessage = "El campo {0} debe tener {1} caracteres o menos")]
   [PrimeraLetraMayuscula] // Validación personalizada en: Domain\Common\Validators\
    public string Nombre { get; set; }

    // --- Propiedad de Navegación (Relación 1-a-Muchos) ---
    // Un planeta puede tener una colección de personajes.
    public virtual ICollection<Personaje> Personajes { get; set; }
}

[Table("Personajes")]
public class Personaje
{
    [Key]
    public int Id { get; set; }

    [Required]
    [StringLength(150)]
    public string Nombre { get; set; }

    // --- Relación 1-a-Muchos (Lado "Muchos") ---

    // 1. La Llave Foránea (Foreign Key - FK)
    // Por convención, EF Core la buscaría como "PlanetaId".
    // La nombramos "PlanetaOrigenId" para ser más descriptivos.
    public int PlanetaOrigenId { get; set; }

    // 2. La Propiedad de Navegación de Referencia (apunta al "Uno")
    [ForeignKey("PlanetaOrigenId")] // Vincula esta navegación con la FK de arriba.
    public virtual Planeta PlanetaOrigen { get; set; }

    // --- Relación Muchos-a-Muchos (con Pelicula) ---
    // EF Core creará una tabla intermedia (ej: "PersonajePelicula")
    [InverseProperty("Personajes")] // Ayuda a EF a saber qué colección en Pelicula es esta.
    public virtual ICollection<Pelicula> Peliculas { get; set; }

    // --- Relación Muchos-a-Muchos (con Nave) ---
    [InverseProperty("Pilotos")] // Se conecta con la propiedad "Pilotos" en la entidad Nave.
    public virtual ICollection<Nave> Naves { get; set; }

    public Personaje()
    {
        Peliculas = new HashSet<Pelicula>();
        Naves = new HashSet<Nave>();
    }
}

[Table("Peliculas")]
public class Pelicula
{
    [Key]
    public int Id { get; set; }

    [Required]
    [StringLength(200)]
    public string Titulo { get; set; }

    public int Episodio { get; set; }

    // --- Relación Muchos-a-Muchos (con Personaje) ---
    [InverseProperty("Peliculas")] // Se conecta con la propiedad "Peliculas" en Personaje.
    public virtual ICollection<Personaje> Personajes { get; set; }

    // --- Relación Muchos-a-Muchos (con Nave) ---
    [InverseProperty("Peliculas")] // Se conecta con la propiedad "Peliculas" en Nave.
    public virtual ICollection<Nave> Naves { get; set; }

    public Pelicula()
    {
        Personajes = new HashSet<Personaje>();
        Naves = new HashSet<Nave>();
    }
}

[Table("Naves")]
public class Nave
{
    [Key]
    public int Id { get; set; }

    [Required]
    [StringLength(150)]
    public string Nombre { get; set; }

    [StringLength(50)]
    public string Modelo { get; set; }

    // --- Relación Muchos-a-Muchos (con Personaje) ---
    // Usamos "Pilotos" para que sea más semántico.
    [InverseProperty("Naves")] // Se conecta con la propiedad "Naves" en Personaje.
    public virtual ICollection<Personaje> Pilotos { get; set; }

    // --- Relación Muchos-a-Muchos (con Pelicula) ---
    [InverseProperty("Naves")] // Se conecta con la propiedad "Naves" en Pelicula.
    public virtual ICollection<Pelicula> Peliculas { get; set; }

    public Nave()
    {
        Pilotos = new HashSet<Personaje>();
        Peliculas = new HashSet<Pelicula>();
    }
}
```

[Key] Identifica la propiedad que será la Llave Primaria (PK) de la tabla.
[Required] Asegura que la propiedad no sea nula. En la base de datos, se traduce como NOT NULL.
[StringLength(int)] Establece la longitud máxima de un campo de texto (ej: nvarchar(100)). Es vital para la eficiencia de la BD.
[Table(string)] (Opcional) Permite nombrar la tabla en la base de datos. Si no se usa, EF Core usará el nombre de la propiedad DbSet en el DbContext (ej: Planetas).
[ForeignKey(string)] Esencial para relaciones. Le indica a EF Core qué propiedad es la Llave Foránea (FK). Se usa en el lado "Muchos" de una relación 1-a-Muchos.
[InverseProperty(string)] Esencial para relaciones complejas. Ayuda a EF Core a "emparejar" las propiedades de navegación cuando hay múltiples relaciones entre dos tablas o en relaciones M-a-M. Le dice: "Esta colección de aquí (ICollection<A>) se corresponde con esta colección de allá (ICollection<B>)".

## Información Adicional y Repaso

virtual y Lazy Loading: La palabra clave virtual en las propiedades de navegación (como virtual ICollection<Personaje>) habilita una característica de EF Core llamada Lazy Loading (Carga Diferida). Esto significa que EF Core no cargará la lista de Personajes cuando consultes un Planeta, sino que solo los cargará de la base de datos en el momento exacto en que intentes acceder a esa propiedad (miPlaneta.Personajes).

ICollection<T> vs List<T>: Usamos ICollection<T> (e inicializamos con HashSet<T>) para las colecciones porque es una interfaz más genérica que List<T>. Representa una "colección de cosas" sin imponer las reglas de una lista (como el orden), lo cual es más eficiente para las operaciones de bases de datos que realiza EF Core.

Tablas Intermedias (Join Tables): En las relaciones Muchos-a-Muchos (como Personaje <-> Pelicula), no necesitas crear una entidad PersonajePelicula. EF Core (versiones modernas) es lo suficientemente inteligente para crear esa tabla "join" automáticamente en la base de datos por ti.

## Validación Personalizada

En este caso creamos las validaciones personalizadas en el directorio (.Domain -> Common -> Validators) debido a que usamos la etiqueta [PrimeraLetraMayuscula] en el modelo.
Otras validaciones pueden ir en el sector de DTOs

```csharp

    [PrimeraLetraMayuscula]
    public string Nombre { get; private set; }

```

/Validators/PrimeraLetraMayuscula.cs

```csharp
namespace StarWarsCRUD.Domain.Common.Validators;
public class PrimeraLetraMayusculaAttribute : ValidationAttribute
{
    protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
    {
        if (value is null || string.IsNullOrEmpty(value.ToString()))
        {
            return ValidationResult.Success;
        }
        var valueString = value.ToString()!;
        var primeraLetra = valueString[0].ToString();
        if (primeraLetra != primeraLetra.ToUpper())
        {
            return new ValidationResult("La primera letra debe ser mayúscula");
        }
        return ValidationResult.Success;
    }
}
```
